!function(){"use strict";class e{static get SHIFT_A(){return"Alt+Shift+A"}static get SHIFT_R(){return"Alt+Shift+R"}static get SHIFT_T(){return"Alt+Shift+T"}static get SHIFT_O(){return"Alt+Shift+O"}static get SHIFT_E(){return"Alt+Shift+E"}static get SHIFT_N(){return"Alt+Shift+N"}static get SHIFT_P(){return"Alt+Shift+P"}static get SHIFT_L(){return"Alt+Shift+L"}static get SHIFT_S(){return"Alt+Shift+S"}static get SHIFT_BACK(){return"Alt+Shift+,"}static get UP_ARROW(){return 38}static get DOWN_ARROW(){return 40}static get CMD_RUN_QUERY(){return"cmd.run-query"}static get CMD_RUN_ALL(){return"cmd.run-all"}static get CMD_FORMAT_QUERY(){return"cmd.format-query"}static get CMD_EXPORT(){return"cmd.export"}static get CMD_CLEAR_FILTER(){return"cmd.clear-filter"}static get CMD_NEXT_ROWS(){return"cmd.next-rows"}static get CMD_PREV_ROWS(){return"cmd.prev-rows"}static get CMD_FORMAT_QUERY(){return"cmd.format-query"}static get CMD_EXPORT_TABLE(){return"cmd.export-table"}static get CMD_SEARCH_TABLES(){return"cmd.search-tables"}static get CMD_BACK(){return"cmd.back"}static get GRID_HAS_FOCUS(){return"grid-has-focus"}static get SEARCH_BAR_HAS_FOCUS(){return"search-bar-has-focus"}static get DB_RENAMED(){return"db-menu.db-renamed"}static get DB_DELETED(){return"db-menu.db-deleted"}static get TABLE_RENAMED(){return"ops-menu.table-renamed"}static get TABLE_TRUNCATED(){return"ops-menu.table-truncated"}static get ROW_SELECTED(){return"table-utils.row-selected"}static get ROW_DELETED(){return"row-deleter.row-deleted"}static get COLUMNS_SELECTED(){return"cmd.columns-selected"}static get STREAM_ERROR(){return"stream.stream-error"}static get SORT_REQUESTED(){return"table-utils.sort-requested"}static get QUERY_CANCELLED(){return"table-utils.query-cancelled"}static get TABLE_SELECTED(){return"tables.table-selected"}static get TABLE_UNSELECTED(){return"tables.table-unselected"}static get CELL_EDITED(){return"tables.cell-edited"}static get TABLE_CHANGED(){return"table-contents.table-changed"}static get DB_CHANGED(){return"appbar.db-changed"}static get GRID_H_RESIZED(){return"gridh.resized"}static get QUERY_DISPATCHED(){return"query-dispatched"}static get FILE_UPLOADED(){return"file-uploaded"}static get QUERY_SAVED(){return"query-saved"}static get CONNECTION_SAVED(){return"connection-saved"}static get CONNECTION_DELETED(){return"connection-deleted"}static get QUERY_UPDATED(){return"query-updated"}static get SESSION_ID(){return"session-id"}static get URL(){return"http://localhost:23890"}static get WS_URL(){return"ws://localhost:23890"}static get DB_NAME(){return"prosql"}static get DB_VERSION(){return 1}static get CONNECTIONS(){return"connections"}static get COLUMN_SELECTIONS(){return"column-selections"}static get BATCH_SIZE(){return 1e3}static get BATCH_SIZE_WS(){return 1e3}static get CREDS(){return"creds"}static get SYSTEM(){return"system"}static get USER(){return"user"}static get DB_ID_INDEX(){return"db-id-index"}static get CONNECTIONS_META_KEY(){return 1}static get QUERIES_META_KEY(){return 2}static get CONNECTIONS_META_DB_VERSION(){return 1}static get QUERIES_META_DB_VERSION(){return 1}static get QUERY_DB_VERSION(){return 39}static get CONN_DB_VERSION(){return 4}static get INIT_PROGRESS(){return"init-progress"}static get START_PROGRESS(){return"start-progress"}static get STOP_PROGRESS(){return"stop-progress"}static get UPDATE_PROGRESS(){return"update-progress"}static get DEBUG_LOG(){return"worker.debug-log"}static get SIGNIN_REQUIRED(){return"worker.signin-required"}static get NEW_CONNECTIONS(){return"worker.new-connection"}static get NEW_QUERIES(){return"worker.new-queries"}static get EXECUTE_SAVE_REC(){return"worker.execute-save-rec"}static get EXECUTE_SUCCESS(){return"app.execute-success"}static get EXECUTE_ERROR(){return"app.execute-error"}static get STATUS_ACTIVE(){return"active"}static get STATUS_DELETED(){return"deleted"}static get EDITOR_TEXT_CHANGED(){return"editor-text-changed"}static get EPOCH_TIMESTAMP(){return"2021-01-01T00:00:00Z"}static get LAST_SYNC_TS(){return"last-sync-ts"}static get CURRENT_PAGE(){return"current-page"}}const t=[];class r{constructor(e=null){this.port=e}log(s,n){t.includes(s)||(this.port?this.port.postMessage({type:e.DEBUG_LOG,payload:`${s}: ${n}`}):r.print(s,n))}static Log(e,s){t.includes(e)||r.print(e,s)}static print(e,t){let[r,s,n]=(new Date).toLocaleDateString("en-US").split("/"),[i,a,o]=(new Date).toLocaleTimeString("en-US").split(/:| /),c=`${s}-${r}-${n} ${i}:${a}:${o}:::${e}: ${t}`;console.log(c)}}class s{static get ERR_NONE(){return"none"}static get ERR_NO_AGENT(){return"no-agent"}static get ERR_INVALID_USER_INPUT(){return"invalid-user-input"}static get ERR_INVALID_SESSION_ID(){return"invalid-session-id"}static get ERR_SIGNIN_REQUIRED(){return"signin-required"}static get ERR_INVALID_CURSOR_ID(){return"invalid-cursor-id"}static get ERR_DB_ERROR(){return"db-error"}static get ERR_UNRECOVERABLE(){return"unrecoverable-error"}static handle(e){e.error!=s.ERR_NO_AGENT?e.error!=s.ERR_INVALID_SESSION_ID?alert(e.error):window.location="/connections":window.location="/install"}}const n="base-db";class i{constructor(e,t){this.logger=e,this.version=t.version,this.dbName=t.dbName}async open(){return new Promise((e,t)=>{let r=indexedDB.open(this.dbName,this.version);r.onsuccess=t=>{this.logger.log(n,"open.onsuccess"),this.db=r.result,e(0)},r.onerror=e=>{this.logger.log(n,e.target.error),t(e.target.errorCode)},r.onupgradeneeded=e=>{this.onUpgrade(e)}})}async save(e,t){return new Promise((r,s)=>{let i=this.db.transaction([e],"readwrite").objectStore(e).add(t);i.onsuccess=e=>{r(e.target.result)},i.onerror=e=>{this.logger.log(n,e.target.error),r(-1)}})}async put(e,t){return new Promise((r,s)=>{let i=this.db.transaction([e],"readwrite").objectStore(e);t.updated_at=new Date;let a=i.put(t);a.onsuccess=e=>{r(0)},a.onerror=e=>{this.logger.log(n,e.target.error),r(-1)}})}async destroy(e){return new Promise((t,r)=>{let s=this.db.transaction(this.store,"readwrite").objectStore(this.store).delete(e);s.onsuccess=e=>{t(0)},s.onerror=e=>{t(e.target.error)}})}async del(t){return new Promise((r,s)=>{let n=this.db.transaction(this.store,"readwrite").objectStore(this.store),i=n.get(t);i.onsuccess=t=>{let s=t.target.result;s.status=e.STATUS_DELETED;let i=n.put(s);i.onerror=e=>{r(e.target.error)},i.onsuccess=e=>{r(0)}},i.onerror=e=>{r(e.target.error)}})}async get(e,t=[]){return new Promise((r,s)=>{let i=this.db.transaction(this.store).objectStore(this.store).get(e);i.onsuccess=e=>{let s=[];if(t.length>0)for(let e in i.result)t.includes(e)&&(s[e]=i.result[e]);else s=i.result;this.logger.log(n,JSON.stringify(s)),r(s)},i.onerror=e=>{r(null)}})}async getAll(e=[]){return new Promise((t,r)=>{let s=this.db.transaction(this.store).objectStore(this.store),n=[];s.openCursor().onsuccess=r=>{var s=r.target.result;if(s){if(e.length>0){let t={};for(let r in s.value)e.includes(r)&&(t[r]=s.value[r]);n.push(t)}else n.push(s.value);s.continue()}else t(n)}})}async reset(t){return new Promise((r,s)=>{let n=this.db.transaction(this.store,"readwrite").objectStore(this.store),i=n.get(t.id);i.onsuccess=t=>{let s=t.target.result;s.db_id=null,s.synced_at=new Date(e.EPOCH_TIMESTAMP);let i=n.put(s);i.onerror=e=>{r(e.target.error)},i.onsuccess=e=>{r(0)}},i.onerror=e=>{r(e.target.error)}})}async sync(e){return new Promise((t,r)=>{let s=this.db.transaction(this.store,"readwrite").objectStore(this.store),n=s.get(e.id);n.onsuccess=r=>{let n=r.target.result;n.db_id=e.db_id,n.synced_at=new Date;let i=s.put(n);i.onerror=e=>{t(e.target.error)},i.onsuccess=e=>{t(0)}},n.onerror=e=>{t(e.target.error)}})}async findByDbId(t){return new Promise((r,s)=>{this.logger.log(n,"findByDbId");let i=this.db.transaction(this.store).objectStore(this.store).index(e.DB_ID_INDEX).get(IDBKeyRange.only([t]));i.onsuccess=e=>{r(i.result)},i.onerror=e=>{this.logger.log(n,"error"),r(e.target.error)}})}static toDb(e={}){let t={};for(let r in e)t[r.replaceAll(/-/g,"_")]=e[r];return t}static toDbArray(e=[]){let t=[];return e.forEach(e=>{t.push(e.replaceAll(/-/g,"_"))}),t}static fromDbArray(e=[]){let t=[];return e.forEach(e=>{let r={};for(let t in e)r[t.replaceAll(/_/g,"-")]=e[t];t.push(r)}),t}static fromDb(e={}){let t={};for(let r in e)t[r.replaceAll(/_/g,"-")]=e[r];return t}}const a="query-db",o="created-at-index",c="term-index",l="tag-index";class g extends i{constructor(e,t){t.dbName="queries",super(e,t),this.logger=e,this.store="queries",this.searchIndex="search-index",this.tagIndex="tag-index"}onUpgrade(t){if(this.logger.log(a,`onUpgrade: o: ${t.oldVersion} n: ${t.newVersion}`),t.oldVersion<2){let e=t.target.result.createObjectStore(this.store,{keyPath:"id",autoIncrement:!0});e.createIndex(o,"created_at",{unique:!1}),e=t.target.result.createObjectStore(this.searchIndex,{keyPath:"id",autoIncrement:!0}),e.createIndex(c,"term",{unique:!0}),e=t.target.result.createObjectStore(this.tagIndex,{keyPath:"id",autoIncrement:!0}),e.createIndex(l,"tag",{unique:!0})}if(t.oldVersion<37){t.currentTarget.transaction.objectStore(this.store).createIndex(e.DB_ID_INDEX,["db_id"])}}async save(e){return new Promise(async(t,r)=>{e.query=e.query.replace(/[ ]{2,}/g," "),this.logger.log(a,JSON.stringify(e.terms));let s=-1;try{if(e.created_at||(e.created_at=new Date),s=await super.save(this.store,e),-1==s)return void t(-1);await this.updateSearchIndex(s,e.terms),await this.updateTagIndex(s,e.tags),t(s)}catch(e){this.logger.log(a,`error: ${JSON.stringify(e.message)}`),r(e.message)}})}async updateSearchIndex(e,t){for(let r=0;r<t.length;r++){let s=t[r];if(s=s.trim(),!(s.length<=1)){s=this.cleanup(s);try{let t=await this.findByTerm(s);if(null==t){await super.save(this.searchIndex,{term:s,queries:[e]});continue}t.queries.push(e),this.logger.log(a,JSON.stringify(t)),super.put(this.searchIndex,{id:t.id,term:s,queries:t.queries})}catch(e){this.logger.log(a,"error: e.message")}}}}async findByTerm(e){return new Promise((t,r)=>{let s=this.db.transaction(this.searchIndex).objectStore(this.searchIndex).index(c),n=IDBKeyRange.only(e);s.openCursor(n).onsuccess=e=>{let r=e.target.result;if(r)return this.logger.log(a,JSON.stringify(r.value)),void t(r.value);t(null)}})}async updateTagIndex(e,t){for(let r=0;r<t.length;r++){let s=t[r];if(s=s.trim(),!(s.length<=1)){s=this.cleanup(s);try{let t=await this.findByTag(s);if(null==t){await super.save(this.tagIndex,{tag:s,queries:[e]});continue}t.queries.push(e),this.logger.log(a,JSON.stringify(t)),super.put(this.tagIndex,{id:t.id,tag:s,queries:t.queries})}catch(e){this.logger.log(a,"error: e.message")}}}}async findByTag(e){return new Promise((t,r)=>{let s=this.db.transaction(this.tagIndex).objectStore(this.tagIndex).index(l),n=IDBKeyRange.only(e);s.openCursor(n).onsuccess=e=>{let r=e.target.result;if(r)return this.logger.log(a,JSON.stringify(r.value)),void t(r.value);t(null)}})}async findByQuery(e){return new Promise((t,r)=>{let s=this.db.transaction(this.dbName).objectStore(this.store).index("query-index"),n=IDBKeyRange.only(e);s.openCursor(n).onsuccess=e=>{let r=e.target.result;if(r)return this.logger.log(a,JSON.stringify(r.value)),void t(r.value);t([])}})}cleanup(e){let t=["`","`"," ",'"',"'",",",";","+","-","=","!=","<",">",">=","<="],r=0,s=(e=e.replace(/^\S+\./,"")).length;for(;r<s&&t.indexOf(e[r])>=0;)++r;for(;s>r&&t.indexOf(e[s-1])>=0;)--s;return r>0||s<e.length?e.substring(r,s):e}async filter(e,t,r){let s,n;this.logger.log(a,`filter: days ${JSON.stringify(e)} tags ${t} terms ${r}`),e.hasOwnProperty("start")&&(s=new Date(Date.now()-24*e.start*60*60*1e3),s.setHours(0),s.setMinutes(0),s.setSeconds(0)),e.hasOwnProperty("end")&&(n=new Date(Date.now()-24*e.end*60*60*1e3),n.setHours(23),n.setMinutes(59),n.setSeconds(59));let i=[];if((s||n)&&(this.logger.log(a,"filtering"),i=await this.searchByCreatedAt(s,n),0==i.length))return[];if(t.length>0){let e=await this.searchByTags(t);if(i=i.filter(t=>e.includes(t)),0==i.length)return[]}if(r.length>0){let e=await this.searchByTerms(r);if(i=i.filter(t=>e.includes(t)),0==i.length)return[]}let o=[];this.logger.log(a,`${i}`);for(let e=0;e<i.length;e++)o.push(await super.get(i[e]));return o}async findByIds(e){return new Promise((t,r)=>{let s=this.db.transaction(this.store).objectStore(this.store),n=[];s.openCursor(null,"prev").onsuccess=r=>{let s=r.target.result;s?(e.includes(s.value.id)&&n.push(s.value),s.continue()):t(n)}})}async updateTags(e){await super.put(this.store,e),await this.updateTagIndex(e.id,e.tags)}searchByTerms(e){return new Promise((t,r)=>{let s=this.db.transaction(this.searchIndex).objectStore(this.searchIndex),n=[];s.openCursor().onsuccess=r=>{let s=r.target.result;s?(e.includes(s.value.term)&&(n=n.concat(s.value.queries)),s.continue()):t(n)}})}searchByTags(e){return new Promise((t,r)=>{let s=this.db.transaction(this.tagIndex).objectStore(this.tagIndex),n=[];s.openCursor().onsuccess=r=>{let s=r.target.result;s?(e.includes(s.value.tag)&&(n=n.concat(s.value.queries)),s.continue()):t(n)}})}listTags(e){return new Promise((t,r)=>{let s=this.db.transaction(this.tagIndex).objectStore(this.tagIndex).index(l),n=[];IDBKeyRange.lowerBound(e),s.openCursor().onsuccess=e=>{let r=e.target.result;r?(n.push(r.value.tag),r.continue()):t(n)}})}listTerms(e){return new Promise((t,r)=>{let s=this.db.transaction(this.searchIndex).objectStore(this.searchIndex).index(c),n=[];IDBKeyRange.lowerBound(e),s.openCursor().onsuccess=e=>{let r=e.target.result;r?(n.push(r.value.term),r.continue()):t(n)}})}searchByCreatedAt(e,t){return new Promise((r,s)=>{this.logger.log(a,`s: ${e} e: ${t}`);let n,i=this.db.transaction(this.store).objectStore(this.store).index(o);if(e&&t)n=IDBKeyRange.bound(e,t);else if(e)n=IDBKeyRange.lowerBound(e);else{if(!t)return void r([]);n=IDBKeyRange.upperBound(t)}let c=[];i.openCursor(n,"prev").onsuccess=e=>{let t=e.target.result;t?(this.logger.log(a,`id: ${t.value.created_at.toISOString()}`),c.push(t.value.id),t.continue()):r(c)}})}}class u extends i{async getDb(){let e=await super.get(parseInt(1));return null==e?"":e.db??""}async setDb(e){this.logger.log("base-meta-db","setDb");let t=await super.get(parseInt(1));null!=t?(t.db=e,await this.put(this.store,t)):await this.save(this.store,{id:parseInt(1),db:e})}async getLastSyncTs(){let t=await super.get(parseInt(1));return null==t?new Date(e.EPOCH_TIMESTAMP):t.last_sync_ts??new Date(e.EPOCH_TIMESTAMP)}async setLastSyncTs(){let e=await super.get(parseInt(1));null!=e?(e.last_sync_ts=new Date,await super.put(this.store,e)):await super.save(this.store,{id:parseInt(1),last_sync_ts:new Date})}async get(){return await super.get(parseInt(1))}async destroy(){return await super.destroy(parseInt(1))}}class d extends u{constructor(e,t){t.dbName="queries_meta",super(e,t),this.logger=e,this.store="queries_meta"}onUpgrade(e){this.logger.log("queries-meta-db",`onUpgrade: o: ${e.oldVersion} n: ${e.newVersion}`),e.oldVersion<1&&e.target.result.createObjectStore(this.store,{keyPath:"id",autoIncrement:!0})}}const h="connection-db",E="connection-index";class _ extends i{constructor(e,t){t.dbName="connections",super(e,t),this.logger=e,this.store="connections"}onUpgrade(t){if(this.logger.log(h,`open.onupgradeneeded: ${t.oldVersion}`),t.oldVersion<1){t.currentTarget.result.createObjectStore(this.store,{keyPath:"id",autoIncrement:!0}).createIndex(E,["name","user","pass","port","db"],{unique:!0})}if(t.oldVersion<2){t.currentTarget.transaction.objectStore(this.store).createIndex(e.DB_ID_INDEX,["id","db_id"],{unique:!0})}if(t.oldVersion<3){let r=t.currentTarget.transaction.objectStore(this.store);r.deleteIndex(E),r.deleteIndex(e.DB_ID_INDEX),r.createIndex(E,["name","user","port","db"],{unique:!0}),r.createIndex(e.DB_ID_INDEX,["db_id"],{unique:!0})}if(t.oldVersion<4){let e=t.currentTarget.transaction.objectStore(this.store);e.deleteIndex(E),e.createIndex(E,["name","user","host","port","db"],{unique:!0})}}async save(e){try{if(1==e.is_default){let e=await super.getAll();for(let t=0;t<e.length;t++)await this.put(e[t].id,e[t].pass,!1)}let t=await this.search(e);return t?(await this.put(t.id,e.pass,e.is_default),t.id):await super.save(this.store,e)}catch(e){this.logger.log(h,e.message)}}async put(e,t,r){return new Promise((s,n)=>{let i=this.db.transaction(this.store,"readwrite").objectStore(this.store),a=i.get(e);a.onsuccess=e=>{let n=e.target.result;t&&(n.pass=t),n.is_default!=r&&(n.updated_at=new Date),n.is_default=r;let a=i.put(n);a.onerror=e=>{s(e.target.error)},a.onsuccess=e=>{s(0)}},a.onerror=e=>{s(e.target.error)}})}async search(e){return new Promise((t,r)=>{let s=this.db.transaction(this.store).objectStore(this.store).index(E).get(IDBKeyRange.only([e.name,e.user,e.host,e.port,e.db]));s.onsuccess=e=>{t(s.result)},s.onerror=e=>{t(e.target.error)}})}}class S extends u{constructor(e,t){t.dbName="connections_meta",super(e,t),this.logger=e,this.store="connections_meta"}onUpgrade(e){this.logger.log("connections-meta-db",`onUpgrade: o: ${e.oldVersion} n: ${e.newVersion}`),e.oldVersion<1&&e.target.result.createObjectStore(this.store,{keyPath:"id",autoIncrement:!0})}}const p="utils";class y{static saveToSession(e,t){window.sessionStorage.setItem(e,t)}static getFromSession(e){return window.sessionStorage.getItem(e)}static removeFromSession(e){window.sessionStorage.removeItem(e)}static saveToLocalStorage(e,t){window.localStorage.setItem(e,t)}static getFromLocalStorage(e){return window.localStorage.getItem(e)??null}static removeFromLocalStorage(e){window.localStorage.removeItem(e)}static processTemplate(e,t){var r=new RegExp(/{(.*?)}/g);return e=e.replace(r,function(e,r){return t[r]||0==t[r]||""==t[r]?t[r]:e})}static generateNode(e,t){e=y.processTemplate(e,t);let r=document.createElement("template");return r.innerHTML=e.trim(),r.content}static async get(e,t=!0,n={}){try{let t={"X-Request-ID":y.uuid()};t={...t,...n};let s=await fetch(e,{headers:t}),i=await s.json();if(r.Log(p,JSON.stringify(i)),"error"==i.status)throw i;return i}catch(e){r.Log(p,JSON.stringify(e));let n={status:"error",data:null};if(e instanceof TypeError)return t?void(window.location="/install"):(n.msg=s.ERR_NO_AGENT,n);if(n.msg=e.msg,n.msg==s.ERR_INVALID_SESSION_ID)return void(window.location="/connections");if(!t)return n;if(n.msg==s.ERR_INVALID_CURSOR_ID)return n;if(n.msg)return alert(n.msg),n}}static async post(e,t,n=!0,i={}){try{let s={"X-Request-ID":y.uuid()};s={...s,...i};let n=new FormData;for(let e in t)n.append(e,t[e]);let a=await fetch(e,{headers:s,body:n,method:"post"}),o=await a.json();if(r.Log(p,JSON.stringify(o)),"error"==o.status)throw o;return o}catch(e){r.Log(p,JSON.stringify(e));let t={status:"error",data:null};if(e instanceof TypeError)return n?void(window.location="/install"):(t.msg=s.ERR_NO_AGENT,t);if(t.msg=e.msg,t.msg==s.ERR_SIGNIN_REQUIRED)return void(window.location="/signin");if(!n)return t;if(t.msg==s.ERR_INVALID_CURSOR_ID)return t;if(t.msg)return alert(t.msg),t}}static async setOptions(e,t,r){e.replaceChildren();let s=document.getElementById("option-template").innerHTML;t.forEach(t=>{let r=y.generateNode(s,{value:t});e.append(r)}),e.value=r}static showAlert(e,t){let r=document.getElementById("alert");r.querySelector(".msg").innerHTML=e,r.style.display="block";let s=document.querySelector("body").getBoundingClientRect();r.style.left=s.width/2+"px",setTimeout(()=>{r.style.display="none"},t)}static showNoData(){r.Log(p,"No data")}static uuid(){return"_"+Math.random().toString(36).substr(2,9)}static getOffset(e){const t=e.getBoundingClientRect();return{left:t.left+window.scrollX,top:t.top+window.scrollY,width:t.width,height:t.height}}static extractColumns(e){let t=[];return e.forEach(e=>{t.push(e[1])}),t}static truncate(e,t){return e.length>t?e.substring(0,t)+"...":e}static getTimestamp(){return(new Date).toISOString().replace(/T/," ").replace(/\..*$/,"")}static getRandomIntegerInclusive(e,t){return Math.floor(Math.random()*(t-e+1))+e}static isEmpty(e){for(var t in e)return!1;return!0}static async resetAll(){let t=new _(new r,{version:e.CONN_DB_VERSION});await t.open();let s=await t.getAll();r.Log(p,"Resetting connections..");for(let e=0;e<s.length;e++)await t.reset(s[e]);r.Log(p,"Done.");let n=new g(new r,{version:e.QUERY_DB_VERSION});await n.open();let i=await n.getAll();r.Log(p,"Resetting queries..");for(let e=0;e<i.length;e++)await n.reset(i[e]);r.Log(p,"Done."),r.Log(p,"Resetting QueriesMetaDB");let a=new d(new r,{version:e.QUERIES_META_DB_VERSION});await a.open(),await a.destroy(),r.Log(p,"Done."),r.Log(p,"Resetting connectionsMetaDb");let o=new S(new r,{version:e.CONNECTIONS_META_DB_VERSION});await o.open(),await o.destroy(),r.Log(p,"Done.")}static async delay(e){return new Promise((t,r)=>{setTimeout(()=>{t()},e)})}static getTerms(e){let t=[],s=sqlFormatter.format(e,{language:"mysql"}).tokens;return r.Log(p,JSON.stringify(s)),s.forEach(e=>{"string"!=e.type&&"word"!=e.type&&"number"!=e.type?/^reserved/.test(e.type)&&t.push(e.value):t.push(e.value)}),t}}const w="base";class D{constructor(e){this.port=e,this.logger=new r(this.port),this.port.onmessage=e=>{this.handleMessage(e)}}async init(){let t=await y.get(e.URL+"/about",!1);"error"!=t.status?(this.logger.log(w,JSON.stringify(t)),this.deviceId=t.data["device-id"],this.logger.log(w,"registering device"),t=await y.post("/worker-api/devices/register",{"device-id":t.data["device-id"],version:t.data.version,os:t.data.os},!1),this.logger.log(w,JSON.stringify(t)),"error"!=t.status?this.db=t.data.db:this.port.postMessage({type:e.SIGNIN_REQUIRED})):this.logger.log(w,JSON.stringify(t))}async reset(e){let t=await e.getAll();for(let r=0;r<t.length;r++)await e.reset(t[r])}}const I="main",R="/worker-api/sqlite";class m extends D{async handleMessage(t){switch(this.logger.log(I,`handleMessage: ${JSON.stringify(t.data)}`),t.data.type){case e.QUERY_SAVED:case e.QUERY_UPDATED:this.syncUp();break;case e.EXECUTE_SUCCESS:this.execResolve&&this.execResolve(t.data.data);break;case e.EXECUTE_ERROR:this.execReject&&this.execReject(t.data.data)}}executeRequest(e,t){return new Promise((r,s)=>{this.port.postMessage({type:e,data:t}),this.execResolve=r,this.execReject=s})}async init(){await super.init(),this.logger.log(I,"deviceid:"+this.deviceId),this.logger.log(I,"db:"+this.db),this.db?(this.queryDb=new g(this.logger,{version:e.QUERY_DB_VERSION}),await this.queryDb.open(),this.metaDB=new d(this.logger,{version:e.QUERIES_META_DB_VERSION}),await this.metaDB.open(),await this.metaDB.getDb()!=this.db&&(await this.reset(this.queryDb),this.logger.log(I,"Reset queryDb"),await this.metaDB.destroy(),await this.metaDB.setDb(this.db)),this.syncDown(),this.syncUp()):this.logger.log(I,"No db")}async syncUp(){let t=await this.queryDb.getAll();if(0==t.length)return void this.logger.log(I,"Nothing to sync");let r=[];for(let s=0;s<t.length;s++){if((t[s].status??e.STATUS_ACTIVE)==e.STATUS_DELETED){if(this.logger.log(I,`Deleting ${t[s].id}`),!t[s].db_id){this.queryDb.del(t[s].id);continue}r.push(t[s]);continue}if(t[s].db_id){let r=t[s].updated_at??new Date(e.EPOCH_TIMESTAMP);if(t[s].synced_at>r){this.logger.log(I,`Skipping ${t[s].id}: ${t[s].db_id}`);continue}}let n=await fetch(`${R}/queries`,{body:JSON.stringify(t[s]),method:"POST",headers:{db:this.db,"Content-Type":"application/json"}});n=await n.json(),this.logger.log(I,JSON.stringify(n)),"ok"==n.status&&(t[s].db_id=n.data.db_id,this.logger.log(I,`syncing: ${JSON.stringify(t[s])}`),this.queryDb.sync(t[s]))}}async syncDown(){this.logger.log(I,"syncDown");let t=await this.metaDB.getLastSyncTs();t=t.toISOString(),this.logger.log(I,`after: ${t}`);let r=!1,s=0;for(;;){let e=await this.fetchRecs(t,50,s);if(this.logger.log(I,`${JSON.stringify(e)}`),"error"==e.status)return void this.logger.log(I,"Syncdown error: "+e.msg);let n=e.data.queries??[];if(0==n.length)break;for(let e=0;e<n.length;e++){this.logger.log(I,`syncDown: ${e}`),this.logger.log(I,`query: ${JSON.stringify(n[e])}`);let t=await this.queryDb.findByDbId(n[e].id);if("deleted"!=n[e].status)if(null==t){await this.insertRec(n[e])>=1&&(r=!0)}else await this.updateRec(t,n[e].tags),r=!0;else await this.deleteRec(t),r=!0}s+=50}r&&this.port.postMessage({type:e.NEW_QUERIES}),this.logger.log(I,"setLastSyncTs:start"),await this.metaDB.setLastSyncTs(),this.logger.log(I,"setLastSyncTs:done")}async fetchRecs(e,t,r){return await y.get(`${R}/queries/updated`,!1,{db:this.db,after:e,limit:t,offset:r})}async insertRec(t){this.logger.log(I,`inserting: ${JSON.stringify(t.id)}`),t.db_id=t.id,delete t.id,t.synced_at=new Date,t.created_at=new Date(t.created_at),t.updated_at=new Date(t.updated_at);let r=this.executeRequest(e.EXECUTE_SAVE_REC,t),s=0;try{s=await r,this.logger.log(I,`execSuccess: ${s}`)}catch(e){this.logger.log(I,`execError: ${e}`)}finally{return s}}async updateRec(e,t){e.tags=t,await this.queryDb.updateTags(e),await this.queryDb.sync(e),this.logger.log(I,`Updated ${e.id}`)}async deleteRec(e){null!=e?(this.logger.log(I,`deleting: ${JSON.stringify(e)}`),await this.queryDb.del(e.id)):this.logger.log(I,"already deleted")}}onconnect=async e=>{let t=e.ports[0];new m(t).init()}}();
